// Generated by picflow 0.1

#include <p18f4520.h>
#include <timers.h>
#include <usart.h>
#include <stdio.h>

// The global variables used throughout the program are declared here
// in one big lump, unless certain antisocial plugins deviate from
// this pristine and beautiful behavior.
void interruptHandlerLow(void);
void sw_timer_isr_G33(void);  // A software timer pseudo-interrupt handler
unsigned long periodic_resetter = 150; // Counter for a software timer
unsigned char dc2 = 64;
void sw_timer_isr_G31(void);  // A software timer pseudo-interrupt handler
unsigned long pwm_timer_counter_G30 = 10; // Counter for a software timer
unsigned char dc1 = 128;
void sw_timer_isr_G28(void);  // A software timer pseudo-interrupt handler
unsigned long pwm_timer_counter_G27 = 10; // Counter for a software timer
void timer0_isr_G26(void);  // Timer0 interrupt handler

// The low-priority interrupt vector will be used for the ordinary
// operation of the program, leaving the high-priority interrupt
// vector free for more urgent things.
#pragma code low_vector=0x18
void low_interrupt(void) {
  _asm goto interruptHandlerLow _endasm;
}

#pragma code
#pragma interrupt interruptHandlerLow
void interruptHandlerLow(void) {
    if (INTCONbits.TMR0IF) timer0_isr_G26();
}


void main(void) {
    // Initialization code for the blocks, in no particular order.
    LATBbits.LATB3 = 0;
    LATBbits.LATB3 = 0;
    OpenTimer0(TIMER_INT_ON & T0_SOURCE_INT & T0_8BIT & T0_PS_1_1);
    
    // Enable interrupts and loop
    INTCONbits.GIE = 1;
    while (1);
}

// Extra code for blocks
// A software timer interrupt handler
void sw_timer_isr_G33(void) {
    dc2 = periodic_resetter;
}

// PWM output auxilliary node event handler. arg will be discarded.
void pwm_output_handler_G32(unsigned long arg) {
    if (LATBbits.LATB3) {
        if (dc2 < 0xFF) LATBbits.LATB3 = 0;
        pwm_timer_counter_G30 = 0xFF - dc2;
    } else {
        if (dc2 > 0) LATBbits.LATB3 = 1;
        pwm_timer_counter_G30 = dc2;
    }
}

// A software timer interrupt handler
void sw_timer_isr_G31(void) {
    pwm_output_handler_G32(pwm_timer_counter_G30);
}

// PWM output auxilliary node event handler. arg will be discarded.
void pwm_output_handler_G29(unsigned long arg) {
    if (LATBbits.LATB3) {
        if (dc1 < 0xFF) LATBbits.LATB3 = 0;
        pwm_timer_counter_G27 = 0xFF - dc1;
    } else {
        if (dc1 > 0) LATBbits.LATB3 = 1;
        pwm_timer_counter_G27 = dc1;
    }
}

// A software timer interrupt handler
void sw_timer_isr_G28(void) {
    pwm_output_handler_G29(pwm_timer_counter_G27);
}

// Timer0 interrupt handler
void timer0_isr_G26(void) {
    INTCONbits.TMR0IF = 0;
    if (--periodic_resetter <= 0) { periodic_resetter = 150; sw_timer_isr_G33(); }
    if (--pwm_timer_counter_G30 <= 0) sw_timer_isr_G31();
    if (--pwm_timer_counter_G27 <= 0) sw_timer_isr_G28();
}
